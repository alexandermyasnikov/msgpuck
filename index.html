<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>MsgPuck: msgpuck.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-45899190-1', 'rtsisyk.github.io');
ga('send', 'pageview');

(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter23087647 = new Ya.Metrika({id:23087647,
                    webvisor:true,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MsgPuck
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">msgpuck.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>MsgPuck is a simple and efficient MsgPack encoder/decoder library in a single self-contained file.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2d475ca7ff94ba648ab4fbdc8e49eabd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d475ca7ff94ba648ab4fbdc8e49eabd"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a2d475ca7ff94ba648ab4fbdc8e49eabd">mp_type</a> { <br />
&#160;&#160;<b>MP_NIL</b> = 0, 
<b>MP_UINT</b>, 
<b>MP_INT</b>, 
<b>MP_STR</b>, 
<br />
&#160;&#160;<b>MP_BIN</b>, 
<b>MP_ARRAY</b>, 
<b>MP_MAP</b>, 
<b>MP_BOOL</b>, 
<br />
&#160;&#160;<b>MP_FLOAT</b>, 
<b>MP_DOUBLE</b>, 
<b>MP_EXT</b>
<br />
 }</td></tr>
<tr class="memdesc:a2d475ca7ff94ba648ab4fbdc8e49eabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">MsgPack data types. <br /></td></tr>
<tr class="separator:a2d475ca7ff94ba648ab4fbdc8e49eabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae2d32cc287216f17cc70aea688183595"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#ae2d32cc287216f17cc70aea688183595">__attribute__</a> ((pure)) enum <a class="el" href="msgpuck_8h.html#a2d475ca7ff94ba648ab4fbdc8e49eabd">mp_type</a> mp_typeof(const char c)</td></tr>
<tr class="memdesc:ae2d32cc287216f17cc70aea688183595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine MsgPack type by a first byte <em>c</em> of encoded data.  <a href="#ae2d32cc287216f17cc70aea688183595">More...</a><br /></td></tr>
<tr class="separator:ae2d32cc287216f17cc70aea688183595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a81b48565b460e79633c88d6568c60f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a4a81b48565b460e79633c88d6568c60f">__attribute__</a> ((const)) uint32_t mp_sizeof_array(uint32_t size)</td></tr>
<tr class="memdesc:a4a81b48565b460e79633c88d6568c60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate exact buffer size needed to store an array header of <em>size</em> elements. Maximum return value is 5. For performance reasons you can preallocate buffer for maximum size without calling the function.  <a href="#a4a81b48565b460e79633c88d6568c60f">More...</a><br /></td></tr>
<tr class="separator:a4a81b48565b460e79633c88d6568c60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb68eba767403432699c731cc953607"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#aefb68eba767403432699c731cc953607">mp_encode_array</a> (char *data, uint32_t size)</td></tr>
<tr class="memdesc:aefb68eba767403432699c731cc953607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an array header of <em>size</em> elements.  <a href="#aefb68eba767403432699c731cc953607">More...</a><br /></td></tr>
<tr class="separator:aefb68eba767403432699c731cc953607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12d3afba83d915dbb9678b5e4c360a3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#aa12d3afba83d915dbb9678b5e4c360a3">mp_decode_array</a> (const char **data)</td></tr>
<tr class="memdesc:aa12d3afba83d915dbb9678b5e4c360a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode an array header from MsgPack <em>data</em>.  <a href="#aa12d3afba83d915dbb9678b5e4c360a3">More...</a><br /></td></tr>
<tr class="separator:aa12d3afba83d915dbb9678b5e4c360a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabd4d215515815ba4974dddd5b084df"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#afabd4d215515815ba4974dddd5b084df">mp_encode_map</a> (char *data, uint32_t size)</td></tr>
<tr class="memdesc:afabd4d215515815ba4974dddd5b084df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a map header of <em>size</em> elements.  <a href="#afabd4d215515815ba4974dddd5b084df">More...</a><br /></td></tr>
<tr class="separator:afabd4d215515815ba4974dddd5b084df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c98c844de9181c4b1fd18296228e7be"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a0c98c844de9181c4b1fd18296228e7be">mp_decode_map</a> (const char **data)</td></tr>
<tr class="memdesc:a0c98c844de9181c4b1fd18296228e7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a map header from MsgPack <em>data</em>.  <a href="#a0c98c844de9181c4b1fd18296228e7be">More...</a><br /></td></tr>
<tr class="separator:a0c98c844de9181c4b1fd18296228e7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c473097cc682ec58c2ea69da40f2f4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a49c473097cc682ec58c2ea69da40f2f4">mp_encode_uint</a> (char *data, uint64_t num)</td></tr>
<tr class="memdesc:a49c473097cc682ec58c2ea69da40f2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an unsigned integer <em>num</em>. It is your responsibility to ensure that <em>data</em> has enough space.  <a href="#a49c473097cc682ec58c2ea69da40f2f4">More...</a><br /></td></tr>
<tr class="separator:a49c473097cc682ec58c2ea69da40f2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3d9c643d49c4ff23432e16e2531d6a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a2e3d9c643d49c4ff23432e16e2531d6a">mp_encode_int</a> (char *data, int64_t num)</td></tr>
<tr class="memdesc:a2e3d9c643d49c4ff23432e16e2531d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a signed integer <em>num</em>. It is your responsibility to ensure that <em>data</em> has enough space.  <a href="#a2e3d9c643d49c4ff23432e16e2531d6a">More...</a><br /></td></tr>
<tr class="separator:a2e3d9c643d49c4ff23432e16e2531d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1877819e684632bd600ee0886c01ae6"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#ab1877819e684632bd600ee0886c01ae6">mp_decode_uint</a> (const char **data)</td></tr>
<tr class="memdesc:ab1877819e684632bd600ee0886c01ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode an unsigned integer from MsgPack <em>data</em>.  <a href="#ab1877819e684632bd600ee0886c01ae6">More...</a><br /></td></tr>
<tr class="separator:ab1877819e684632bd600ee0886c01ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410cccb0859f6d7337c20a62e7f72bc4"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a410cccb0859f6d7337c20a62e7f72bc4">mp_decode_int</a> (const char **data)</td></tr>
<tr class="memdesc:a410cccb0859f6d7337c20a62e7f72bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a signed integer from MsgPack <em>data</em>.  <a href="#a410cccb0859f6d7337c20a62e7f72bc4">More...</a><br /></td></tr>
<tr class="separator:a410cccb0859f6d7337c20a62e7f72bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1793e9942a486ea2319e92bd9050cbfc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a1793e9942a486ea2319e92bd9050cbfc">mp_encode_float</a> (char *data, float num)</td></tr>
<tr class="memdesc:a1793e9942a486ea2319e92bd9050cbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a float <em>num</em>. It is your responsibility to ensure that <em>data</em> has enough space.  <a href="#a1793e9942a486ea2319e92bd9050cbfc">More...</a><br /></td></tr>
<tr class="separator:a1793e9942a486ea2319e92bd9050cbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cc4a438ffb7a01188aa980efd55a26"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a74cc4a438ffb7a01188aa980efd55a26">mp_encode_double</a> (char *data, double num)</td></tr>
<tr class="memdesc:a74cc4a438ffb7a01188aa980efd55a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a double <em>num</em>. It is your responsibility to ensure that <em>data</em> has enough space.  <a href="#a74cc4a438ffb7a01188aa980efd55a26">More...</a><br /></td></tr>
<tr class="separator:a74cc4a438ffb7a01188aa980efd55a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da52b82b517517c7f951352f97895be"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a0da52b82b517517c7f951352f97895be">mp_decode_float</a> (const char **data)</td></tr>
<tr class="memdesc:a0da52b82b517517c7f951352f97895be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a float from MsgPack <em>data</em>.  <a href="#a0da52b82b517517c7f951352f97895be">More...</a><br /></td></tr>
<tr class="separator:a0da52b82b517517c7f951352f97895be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28071d0cd3692dcef2c8815736f2bd60"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a28071d0cd3692dcef2c8815736f2bd60">mp_decode_double</a> (const char **data)</td></tr>
<tr class="memdesc:a28071d0cd3692dcef2c8815736f2bd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a double from MsgPack <em>data</em>.  <a href="#a28071d0cd3692dcef2c8815736f2bd60">More...</a><br /></td></tr>
<tr class="separator:a28071d0cd3692dcef2c8815736f2bd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed3db6110d7c12dc5129fe643566c28"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a4ed3db6110d7c12dc5129fe643566c28">mp_encode_strl</a> (char *data, uint32_t len)</td></tr>
<tr class="memdesc:a4ed3db6110d7c12dc5129fe643566c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a string header of length <em>len</em>.  <a href="#a4ed3db6110d7c12dc5129fe643566c28">More...</a><br /></td></tr>
<tr class="separator:a4ed3db6110d7c12dc5129fe643566c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e8044ca31b3e4011dac8d96340a5dd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#aa1e8044ca31b3e4011dac8d96340a5dd">mp_encode_str</a> (char *data, const char *str, uint32_t len)</td></tr>
<tr class="memdesc:aa1e8044ca31b3e4011dac8d96340a5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a string of length <em>len</em>. The function is equivalent to <a class="el" href="index.html#a4ed3db6110d7c12dc5129fe643566c28" title="Encode a string header of length len. ">mp_encode_strl()</a> + memcpy.  <a href="#aa1e8044ca31b3e4011dac8d96340a5dd">More...</a><br /></td></tr>
<tr class="separator:aa1e8044ca31b3e4011dac8d96340a5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2b1df405a632b0761c04323299a970"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#ace2b1df405a632b0761c04323299a970">mp_encode_binl</a> (char *data, uint32_t len)</td></tr>
<tr class="memdesc:ace2b1df405a632b0761c04323299a970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a binstring header of length <em>len</em>. See <a class="el" href="index.html#a4ed3db6110d7c12dc5129fe643566c28" title="Encode a string header of length len. ">mp_encode_strl()</a> for more details.  <a href="#ace2b1df405a632b0761c04323299a970">More...</a><br /></td></tr>
<tr class="separator:ace2b1df405a632b0761c04323299a970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726422a3e62a43676ff45224e64e8212"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a726422a3e62a43676ff45224e64e8212">mp_encode_bin</a> (char *data, const char *str, uint32_t len)</td></tr>
<tr class="memdesc:a726422a3e62a43676ff45224e64e8212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a binstring of length <em>len</em>. The function is equivalent to <a class="el" href="index.html#ace2b1df405a632b0761c04323299a970" title="Encode a binstring header of length len. See mp_encode_strl() for more details. ">mp_encode_binl()</a> + memcpy.  <a href="#a726422a3e62a43676ff45224e64e8212">More...</a><br /></td></tr>
<tr class="separator:a726422a3e62a43676ff45224e64e8212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada74df4f72bab98a89ac57aec6ae01b9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#ada74df4f72bab98a89ac57aec6ae01b9">mp_format</a> (char *data, size_t data_size, const char *format,...)</td></tr>
<tr class="memdesc:ada74df4f72bab98a89ac57aec6ae01b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a sequence of values according to format string. Example: mp_format(buf, sz, "[%d {%d%s%d%s}]", 42, 0, "false", 1, "true"); to get a msgpack array of two items: number 42 and map (0-&gt;"false, 2-&gt;"true") Does not write items that don't fit to data_size argument.  <a href="#ada74df4f72bab98a89ac57aec6ae01b9">More...</a><br /></td></tr>
<tr class="separator:ada74df4f72bab98a89ac57aec6ae01b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a50574a11a134d27d093e9ea341622d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a7a50574a11a134d27d093e9ea341622d">mp_vformat</a> (char *data, size_t data_size, const char *format, va_list args)</td></tr>
<tr class="memdesc:a7a50574a11a134d27d093e9ea341622d"><td class="mdescLeft">&#160;</td><td class="mdescRight">mp_format variation, taking variable argument list Example: va_list args; va_start(args, fmt); mp_vformat(data, data_size, fmt, args); va_end(args);  <a href="#a7a50574a11a134d27d093e9ea341622d">More...</a><br /></td></tr>
<tr class="separator:a7a50574a11a134d27d093e9ea341622d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b717213c64e3bdf665820acb2ae768c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a0b717213c64e3bdf665820acb2ae768c">mp_decode_strl</a> (const char **data)</td></tr>
<tr class="memdesc:a0b717213c64e3bdf665820acb2ae768c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a length of a string from MsgPack <em>data</em>.  <a href="#a0b717213c64e3bdf665820acb2ae768c">More...</a><br /></td></tr>
<tr class="separator:a0b717213c64e3bdf665820acb2ae768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60224a98b8f0f8269d005bf080621f94"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a60224a98b8f0f8269d005bf080621f94">mp_decode_str</a> (const char **data, uint32_t *len)</td></tr>
<tr class="memdesc:a60224a98b8f0f8269d005bf080621f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string from MsgPack <em>data</em>.  <a href="#a60224a98b8f0f8269d005bf080621f94">More...</a><br /></td></tr>
<tr class="separator:a60224a98b8f0f8269d005bf080621f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b8bf254b190354c4bf29bff4e2a155"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#ac1b8bf254b190354c4bf29bff4e2a155">mp_decode_binl</a> (const char **data)</td></tr>
<tr class="memdesc:ac1b8bf254b190354c4bf29bff4e2a155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a length of a binstring from MsgPack <em>data</em>.  <a href="#ac1b8bf254b190354c4bf29bff4e2a155">More...</a><br /></td></tr>
<tr class="separator:ac1b8bf254b190354c4bf29bff4e2a155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0871f476708b1ac83200a2ed1094131e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a0871f476708b1ac83200a2ed1094131e">mp_decode_bin</a> (const char **data, uint32_t *len)</td></tr>
<tr class="memdesc:a0871f476708b1ac83200a2ed1094131e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a binstring from MsgPack <em>data</em>.  <a href="#a0871f476708b1ac83200a2ed1094131e">More...</a><br /></td></tr>
<tr class="separator:a0871f476708b1ac83200a2ed1094131e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5097e4ef9751b87eecf075ccb1ac18"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#aea5097e4ef9751b87eecf075ccb1ac18">mp_encode_nil</a> (char *data)</td></tr>
<tr class="memdesc:aea5097e4ef9751b87eecf075ccb1ac18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the nil value. It is your responsibility to ensure that <em>data</em> has enough space.  <a href="#aea5097e4ef9751b87eecf075ccb1ac18">More...</a><br /></td></tr>
<tr class="separator:aea5097e4ef9751b87eecf075ccb1ac18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07498f4874cbf2b082750216e414edf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a07498f4874cbf2b082750216e414edf2">mp_decode_nil</a> (const char **data)</td></tr>
<tr class="memdesc:a07498f4874cbf2b082750216e414edf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the nil value from MsgPack <em>data</em>.  <a href="#a07498f4874cbf2b082750216e414edf2">More...</a><br /></td></tr>
<tr class="separator:a07498f4874cbf2b082750216e414edf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83ed15f5199c7717492f50acdec79f4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#ab83ed15f5199c7717492f50acdec79f4">mp_encode_bool</a> (char *data, bool val)</td></tr>
<tr class="memdesc:ab83ed15f5199c7717492f50acdec79f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a bool value <em>val</em>. It is your responsibility to ensure that <em>data</em> has enough space.  <a href="#ab83ed15f5199c7717492f50acdec79f4">More...</a><br /></td></tr>
<tr class="separator:ab83ed15f5199c7717492f50acdec79f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3042689fde2eee585cb5a2bcf1ff45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a2d3042689fde2eee585cb5a2bcf1ff45">mp_decode_bool</a> (const char **data)</td></tr>
<tr class="memdesc:a2d3042689fde2eee585cb5a2bcf1ff45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a bool value from MsgPack <em>data</em>.  <a href="#a2d3042689fde2eee585cb5a2bcf1ff45">More...</a><br /></td></tr>
<tr class="separator:a2d3042689fde2eee585cb5a2bcf1ff45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf842a6e84f360fd9b9fc4dca35c8529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#abf842a6e84f360fd9b9fc4dca35c8529">mp_next</a> (const char **data)</td></tr>
<tr class="memdesc:abf842a6e84f360fd9b9fc4dca35c8529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip one element in a packed <em>data</em>.  <a href="#abf842a6e84f360fd9b9fc4dca35c8529">More...</a><br /></td></tr>
<tr class="separator:abf842a6e84f360fd9b9fc4dca35c8529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37935b46378b538ca5c784b66d19cd61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index.html#a37935b46378b538ca5c784b66d19cd61">mp_check</a> (const char **data, const char *end)</td></tr>
<tr class="memdesc:a37935b46378b538ca5c784b66d19cd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="index.html#abf842a6e84f360fd9b9fc4dca35c8529" title="Skip one element in a packed data. ">mp_next()</a> but also validates MsgPack in <em>data</em>.  <a href="#a37935b46378b538ca5c784b66d19cd61">More...</a><br /></td></tr>
<tr class="separator:a37935b46378b538ca5c784b66d19cd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abe43fe84431eb0cabf3c21ccc94bd756"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe43fe84431eb0cabf3c21ccc94bd756"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>end</b></td></tr>
<tr class="separator:abe43fe84431eb0cabf3c21ccc94bd756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc7e90968ccd30f5e88dce20256b4ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cc7e90968ccd30f5e88dce20256b4ab"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>data_b</b></td></tr>
<tr class="separator:a0cc7e90968ccd30f5e88dce20256b4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>MsgPuck is a simple and efficient MsgPack encoder/decoder library in a single self-contained file. </p>
<p>MsgPuck Usage example: </p><div class="fragment"><div class="line"><span class="comment">// Encode</span></div>
<div class="line"><span class="keywordtype">char</span> buf[1024];</div>
<div class="line"><span class="keywordtype">char</span> *w = buf;</div>
<div class="line">w = <a class="code" href="index.html#aefb68eba767403432699c731cc953607">mp_encode_array</a>(w, 4)</div>
<div class="line">w = <a class="code" href="index.html#a49c473097cc682ec58c2ea69da40f2f4">mp_encode_uint</a>(w, 10);</div>
<div class="line">w = <a class="code" href="index.html#aa1e8044ca31b3e4011dac8d96340a5dd">mp_encode_str</a>(w, &quot;hello world&quot;, strlen(&quot;hello world&quot;));</div>
<div class="line">w = <a class="code" href="index.html#ab83ed15f5199c7717492f50acdec79f4">mp_encode_bool</a>(w, true);</div>
<div class="line">w = <a class="code" href="index.html#a74cc4a438ffb7a01188aa980efd55a26">mp_encode_double</a>(w, 3.1415);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Validate</span></div>
<div class="line">const <span class="keywordtype">char</span> *b = buf;</div>
<div class="line"><span class="keywordtype">int</span> r = <a class="code" href="index.html#a37935b46378b538ca5c784b66d19cd61">mp_check</a>(&amp;b, w);</div>
<div class="line">assert(!r)</div>
<div class="line">assert(b == w);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Decode</span></div>
<div class="line">uint32_t size;</div>
<div class="line">uint64_t ival;</div>
<div class="line">const <span class="keywordtype">char</span> *sval;</div>
<div class="line">uint32_t sval_len;</div>
<div class="line"><span class="keywordtype">bool</span> bval;</div>
<div class="line"><span class="keywordtype">double</span> dval;</div>
<div class="line"></div>
<div class="line">const <span class="keywordtype">char</span> *r = buf;</div>
<div class="line"></div>
<div class="line">size = <a class="code" href="index.html#aa12d3afba83d915dbb9678b5e4c360a3">mp_decode_array</a>(&amp;r);</div>
<div class="line"><span class="comment">// size is 4</span></div>
<div class="line"></div>
<div class="line">ival = <a class="code" href="index.html#ab1877819e684632bd600ee0886c01ae6">mp_decode_uint</a>(&amp;r);</div>
<div class="line"><span class="comment">// ival is 10;</span></div>
<div class="line"></div>
<div class="line">sval = <a class="code" href="index.html#a60224a98b8f0f8269d005bf080621f94">mp_decode_str</a>(&amp;r, &amp;sval_len);</div>
<div class="line"><span class="comment">// sval is &quot;hello world&quot;, sval_len is strlen(&quot;hello world&quot;)</span></div>
<div class="line"></div>
<div class="line">bval = <a class="code" href="index.html#a2d3042689fde2eee585cb5a2bcf1ff45">mp_decode_bool</a>(&amp;r);</div>
<div class="line"><span class="comment">// bval is true</span></div>
<div class="line"></div>
<div class="line">dval = <a class="code" href="index.html#a28071d0cd3692dcef2c8815736f2bd60">mp_decode_double</a>(&amp;r);</div>
<div class="line"><span class="comment">// dval is 3.1415</span></div>
<div class="line"></div>
<div class="line">assert(r == w);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Supported compilers. The implementation requires a C99+ or C++03+ compatible compiler.</dd>
<dd>
Inline functions. The implementation is compatible with both C99 and GNU inline functions. Please define MP_SOURCE 1 before #include &lt;<a class="el" href="index.html" title="MsgPuck is a simple and efficient MsgPack encoder/decoder library in a single self-contained file...">msgpuck.h</a>&gt; in a single compilation unit. This module will be used to store non-inlined versions of functions and global tables. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae2d32cc287216f17cc70aea688183595"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(pure)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine MsgPack type by a first byte <em>c</em> of encoded data. </p>
<p>Check that <em>cur</em> buffer has enough bytes to decode a bool value.</p>
<p>Check that <em>cur</em> buffer has enough bytes to decode nil.</p>
<p>Check that <em>cur</em> buffer has enough bytes to decode a binstring header.</p>
<p>Check that <em>cur</em> buffer has enough bytes to decode a string header.</p>
<p>Check that <em>cur</em> buffer has enough bytes to decode a double.</p>
<p>Check that <em>cur</em> buffer has enough bytes to decode a float.</p>
<p>Compare two packed unsigned integers.</p>
<p>Check that <em>cur</em> buffer has enough bytes to decode an int.</p>
<p>Check that <em>cur</em> buffer has enough bytes to decode an uint.</p>
<p>Check that <em>cur</em> buffer has enough bytes to decode a map header.</p>
<p>Check that <em>cur</em> buffer has enough bytes to decode an array header.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;assert(MP_ARRAY == mp_typeof(0x90));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- a first byte of encoded data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MsgPack type</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur</td><td>buffer </td></tr>
    <tr><td class="paramname">end</td><td>end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- buffer has enough bytes </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 - the number of remaining bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>cur &lt; end </dd>
<dd>
mp_typeof(*cur) == MP_ARRAY</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur</td><td>buffer </td></tr>
    <tr><td class="paramname">end</td><td>end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- buffer has enough bytes </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 - the number of remaining bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>cur &lt; end </dd>
<dd>
mp_typeof(*cur) == MP_MAP</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur</td><td>buffer </td></tr>
    <tr><td class="paramname">end</td><td>end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- buffer has enough bytes </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 - the number of remaining bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>cur &lt; end </dd>
<dd>
mp_typeof(*cur) == MP_UINT</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur</td><td>buffer </td></tr>
    <tr><td class="paramname">end</td><td>end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- buffer has enough bytes </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 - the number of remaining bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>cur &lt; end </dd>
<dd>
mp_typeof(*cur) == MP_INT</dd></dl>
<p>The function is faster than two <a class="el" href="index.html#ab1877819e684632bd600ee0886c01ae6" title="Decode an unsigned integer from MsgPack data. ">mp_decode_uint()</a> calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_a</td><td>unsigned int a </td></tr>
    <tr><td class="paramname">data_b</td><td>unsigned int b </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;</td><td>0 when <em>a</em> &lt; <em>b</em> </td></tr>
    <tr><td class="paramname">0</td><td>when <em>a</em> == <em>b</em> </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 when <em>a</em> &gt; <em>b</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur</td><td>buffer </td></tr>
    <tr><td class="paramname">end</td><td>end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- buffer has enough bytes </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 - the number of remaining bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>cur &lt; end </dd>
<dd>
mp_typeof(*cur) == MP_FLOAT</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur</td><td>buffer </td></tr>
    <tr><td class="paramname">end</td><td>end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- buffer has enough bytes </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 - the number of remaining bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>cur &lt; end </dd>
<dd>
mp_typeof(*cur) == MP_DOUBLE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur</td><td>buffer </td></tr>
    <tr><td class="paramname">end</td><td>end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- buffer has enough bytes </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 - the number of remaining bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>cur &lt; end </dd>
<dd>
mp_typeof(*cur) == MP_STR</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur</td><td>buffer </td></tr>
    <tr><td class="paramname">end</td><td>end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- buffer has enough bytes </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 - the number of remaining bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>cur &lt; end </dd>
<dd>
mp_typeof(*cur) == MP_BIN</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur</td><td>buffer </td></tr>
    <tr><td class="paramname">end</td><td>end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- buffer has enough bytes </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 - the number of remaining bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>cur &lt; end </dd>
<dd>
mp_typeof(*cur) == MP_NIL</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur</td><td>buffer </td></tr>
    <tr><td class="paramname">end</td><td>end of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- buffer has enough bytes </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 - the number of remaining bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>cur &lt; end </dd>
<dd>
mp_typeof(*cur) == MP_BOOL </dd></dl>

</div>
</div>
<a class="anchor" id="a4a81b48565b460e79633c88d6568c60f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(const)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate exact buffer size needed to store an array header of <em>size</em> elements. Maximum return value is 5. For performance reasons you can preallocate buffer for maximum size without calling the function. </p>
<p>Calculate exact buffer size needed to store a boolean value. The return value is always 1. The function was added to provide integrity of the library.</p>
<p>Calculate exact buffer size needed to store the nil value. The return value is always 1. The function was added to provide integrity of the library.</p>
<p>Equivalent to mp_sizeof_binl(<em>len</em>) + <em>len</em>.</p>
<p>Calculate exact buffer size needed to store a binstring header of length <em>num</em>. Maximum return value is 5. For performance reasons you can preallocate buffer for maximum size without calling the function.</p>
<p>Equivalent to mp_sizeof_strl(<em>len</em>) + <em>len</em>.</p>
<p>Calculate exact buffer size needed to store a string header of length <em>num</em>. Maximum return value is 5. For performance reasons you can preallocate buffer for maximum size without calling the function.</p>
<p>Calculate exact buffer size needed to store a double <em>num</em>. The return value is either 5 or 9. The function was added to provide integrity of the library. For performance reasons you can preallocate buffer for maximum size without calling the function.</p>
<p>Calculate exact buffer size needed to store a float <em>num</em>. The return value is always 5. The function was added to provide integrity of the library.</p>
<p>Calculate exact buffer size needed to store an integer <em>num</em>. Maximum return value is 9. For performance reasons you can preallocate buffer for maximum size without calling the function.</p>
<p>Calculate exact buffer size needed to store an integer <em>num</em>. Maximum return value is 9. For performance reasons you can preallocate buffer for maximum size without calling the function. Example usage:</p>
<p>Calculate exact buffer size needed to store a map header of <em>size</em> elements. Maximum return value is 5. For performance reasons you can preallocate buffer for maximum size without calling the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>- a number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer size in bytes (max is 5)</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char **data = ...;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;char *end = *data;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;my_buffer_ensure(mp_sizeof_uint(x), &amp;end);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// my_buffer_ensure(9, &amp;end);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;mp_encode_uint(buffer, x);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>- a number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer size in bytes (max is 9)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>- a number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer size in bytes (max is 9) </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>num</em> &lt; 0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>- a float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer size in bytes (always 5)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>- a double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer size in bytes (5 or 9)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>- a string length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size in chars (max is 5)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>- a string length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size in chars (max is 5 + <em>len</em>)</dd>
<dd>
buffer size in bytes (always 1) </dd></dl>

</div>
</div>
<a class="anchor" id="a37935b46378b538ca5c784b66d19cd61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mp_check </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="index.html#abf842a6e84f360fd9b9fc4dca35c8529" title="Skip one element in a packed data. ">mp_next()</a> but also validates MsgPack in <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
    <tr><td class="paramname">end</td><td>- the end of a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>when MsgPack in <em>data</em> is valid. </td></tr>
    <tr><td class="paramname">!=</td><td>0 when MsgPack in <em>data</em> is not valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_TYPE() where TYPE is mp_typeof(**data) </dd>
<dd>
*data is not defined if MsgPack is not valid </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#abf842a6e84f360fd9b9fc4dca35c8529" title="Skip one element in a packed data. ">mp_next()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa12d3afba83d915dbb9678b5e4c360a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mp_decode_array </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode an array header from MsgPack <em>data</em>. </p>
<p>All array members must be decoded after the header. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of elements in an array </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_array(retval) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#aefb68eba767403432699c731cc953607">An usage example </a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0871f476708b1ac83200a2ed1094131e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mp_decode_bin </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a binstring from MsgPack <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
    <tr><td class="paramname">len</td><td>- the pointer to save a binstring length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a decoded binstring </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_str(*len) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#ace2b1df405a632b0761c04323299a970" title="Encode a binstring header of length len. See mp_encode_strl() for more details. ">mp_encode_binl</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac1b8bf254b190354c4bf29bff4e2a155"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mp_decode_binl </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a length of a binstring from MsgPack <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a length of a binstring </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_binl(retval) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#ace2b1df405a632b0761c04323299a970" title="Encode a binstring header of length len. See mp_encode_strl() for more details. ">mp_encode_binl</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2d3042689fde2eee585cb5a2bcf1ff45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mp_decode_bool </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a bool value from MsgPack <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a decoded bool value </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_bool(retval) </dd></dl>

</div>
</div>
<a class="anchor" id="a28071d0cd3692dcef2c8815736f2bd60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mp_decode_double </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a double from MsgPack <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a double </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_double(retval) </dd></dl>

</div>
</div>
<a class="anchor" id="a0da52b82b517517c7f951352f97895be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mp_decode_float </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a float from MsgPack <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a float </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_float(retval) </dd></dl>

</div>
</div>
<a class="anchor" id="a410cccb0859f6d7337c20a62e7f72bc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mp_decode_int </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a signed integer from MsgPack <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an unsigned number </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_int(retval) </dd></dl>

</div>
</div>
<a class="anchor" id="a0c98c844de9181c4b1fd18296228e7be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mp_decode_map </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a map header from MsgPack <em>data</em>. </p>
<p>All map key-value pairs must be decoded after the header. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of key/value pairs in a map </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_array(retval) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#afabd4d215515815ba4974dddd5b084df">An usage example </a> </dd></dl>

</div>
</div>
<a class="anchor" id="a07498f4874cbf2b082750216e414edf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mp_decode_nil </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the nil value from MsgPack <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_nil() </dd></dl>

</div>
</div>
<a class="anchor" id="a60224a98b8f0f8269d005bf080621f94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mp_decode_str </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a string from MsgPack <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
    <tr><td class="paramname">len</td><td>- the pointer to save a string length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a decoded string </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_str(*len) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#ace2b1df405a632b0761c04323299a970" title="Encode a binstring header of length len. See mp_encode_strl() for more details. ">mp_encode_binl</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0b717213c64e3bdf665820acb2ae768c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mp_decode_strl </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a length of a string from MsgPack <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a length of astring </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_strl(retval) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#a4ed3db6110d7c12dc5129fe643566c28" title="Encode a string header of length len. ">mp_encode_strl</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1877819e684632bd600ee0886c01ae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mp_decode_uint </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode an unsigned integer from MsgPack <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an unsigned number </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_uint(retval) </dd></dl>

</div>
</div>
<a class="anchor" id="aefb68eba767403432699c731cc953607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mp_encode_array </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode an array header of <em>size</em> elements. </p>
<p>All array members must be encoded after the header.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Encode</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;char buf[1024];</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;char *w = buf;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;w = mp_encode_array(w, 2)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;w = mp_encode_uint(w, 10);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;w = mp_encode_uint(w, 15);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;// Decode</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;const char *r = buf;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;uint32_t size = mp_decode_array(&amp;r);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;for (uint32_t i = 0; i &lt; size; i++) {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    uint64_t val = mp_decode_uint(&amp;r);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;assert (r == w);</div>
</div><!-- fragment --><p> It is your responsibility to ensure that <em>data</em> has enough space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a buffer </td></tr>
    <tr><td class="paramname">size</td><td>- a number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + <a class="el" href="">mp_sizeof_array(size) </a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>mp_sizeof_array </dd></dl>

</div>
</div>
<a class="anchor" id="a726422a3e62a43676ff45224e64e8212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mp_encode_bin </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a binstring of length <em>len</em>. The function is equivalent to <a class="el" href="index.html#ace2b1df405a632b0761c04323299a970" title="Encode a binstring header of length len. See mp_encode_strl() for more details. ">mp_encode_binl()</a> + memcpy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a buffer </td></tr>
    <tr><td class="paramname">str</td><td>- a pointer to binstring data </td></tr>
    <tr><td class="paramname">len</td><td>- a binstring length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + mp_sizeof_bin(<em>len</em>) == data + mp_sizeof_binl(<em>len</em>) + <em>len</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#a4ed3db6110d7c12dc5129fe643566c28" title="Encode a string header of length len. ">mp_encode_strl</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ace2b1df405a632b0761c04323299a970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mp_encode_binl </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a binstring header of length <em>len</em>. See <a class="el" href="index.html#a4ed3db6110d7c12dc5129fe643566c28" title="Encode a string header of length len. ">mp_encode_strl()</a> for more details. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a bufer </td></tr>
    <tr><td class="paramname">len</td><td>- a string length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data + mp_sizeof_binl(<em>len</em>) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#a4ed3db6110d7c12dc5129fe643566c28" title="Encode a string header of length len. ">mp_encode_strl</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab83ed15f5199c7717492f50acdec79f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mp_encode_bool </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a bool value <em>val</em>. It is your responsibility to ensure that <em>data</em> has enough space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a buffer </td></tr>
    <tr><td class="paramname">val</td><td>- a bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + mp_sizeof_bool(val) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#aefb68eba767403432699c731cc953607">An usage example </a> </dd>
<dd>
mp_sizeof_bool() </dd></dl>

</div>
</div>
<a class="anchor" id="a74cc4a438ffb7a01188aa980efd55a26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mp_encode_double </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a double <em>num</em>. It is your responsibility to ensure that <em>data</em> has enough space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a buffer </td></tr>
    <tr><td class="paramname">num</td><td>- a float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + mp_sizeof_double(<em>num</em>) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#aefb68eba767403432699c731cc953607">An usage example </a> </dd>
<dd>
mp_sizeof_double() </dd></dl>

</div>
</div>
<a class="anchor" id="a1793e9942a486ea2319e92bd9050cbfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mp_encode_float </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a float <em>num</em>. It is your responsibility to ensure that <em>data</em> has enough space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a buffer </td></tr>
    <tr><td class="paramname">num</td><td>- a float </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + mp_sizeof_float(<em>num</em>) </dd></dl>
<dl class="section see"><dt>See also</dt><dd>mp_sizeof_float() </dd>
<dd>
<a class="el" href="index.html#aefb68eba767403432699c731cc953607">An usage example </a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2e3d9c643d49c4ff23432e16e2531d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mp_encode_int </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a signed integer <em>num</em>. It is your responsibility to ensure that <em>data</em> has enough space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a buffer </td></tr>
    <tr><td class="paramname">num</td><td>- a number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + mp_sizeof_int(<em>num</em>) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#aefb68eba767403432699c731cc953607">An usage example </a> </dd>
<dd>
mp_sizeof_int() </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>num</em> &lt; 0 </dd></dl>

</div>
</div>
<a class="anchor" id="afabd4d215515815ba4974dddd5b084df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mp_encode_map </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a map header of <em>size</em> elements. </p>
<p>All map key-value pairs must be encoded after the header.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char buf[1024];</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;// Encode</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;char *w = buf;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;w = mp_encode_map(b, 2);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;w = mp_encode_str(b, &quot;key1&quot;, 4);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;w = mp_encode_str(b, &quot;value1&quot;, 6);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;w = mp_encode_str(b, &quot;key2&quot;, 4);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;w = mp_encode_str(b, &quot;value2&quot;, 6);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;// Decode</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;const char *r = buf;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;uint32_t size = mp_decode_map(&amp;r);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;for (uint32_t i = 0; i &lt; size; i++) {</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;     // Use switch(mp_typeof(**r)) to support more types</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    uint32_t key_len, val_len;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    const char *key = mp_decode_str(&amp;r, key_len);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    const char *val = mp_decode_str(&amp;r, val_len);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;}</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;assert (r == w);</div>
</div><!-- fragment --><p> It is your responsibility to ensure that <em>data</em> has enough space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a buffer </td></tr>
    <tr><td class="paramname">size</td><td>- a number of key/value pairs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + <a class="el" href="">mp_sizeof_map(size)</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>mp_sizeof_map </dd></dl>

</div>
</div>
<a class="anchor" id="aea5097e4ef9751b87eecf075ccb1ac18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mp_encode_nil </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the nil value. It is your responsibility to ensure that <em>data</em> has enough space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + mp_sizeof_nil() </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#aefb68eba767403432699c731cc953607">An usage example </a> </dd>
<dd>
mp_sizeof_nil() </dd></dl>

</div>
</div>
<a class="anchor" id="aa1e8044ca31b3e4011dac8d96340a5dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mp_encode_str </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a string of length <em>len</em>. The function is equivalent to <a class="el" href="index.html#a4ed3db6110d7c12dc5129fe643566c28" title="Encode a string header of length len. ">mp_encode_strl()</a> + memcpy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a buffer </td></tr>
    <tr><td class="paramname">str</td><td>- a pointer to string data </td></tr>
    <tr><td class="paramname">len</td><td>- a string length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + mp_sizeof_str(len) == data + mp_sizeof_strl(len) + len </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#a4ed3db6110d7c12dc5129fe643566c28" title="Encode a string header of length len. ">mp_encode_strl</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4ed3db6110d7c12dc5129fe643566c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mp_encode_strl </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a string header of length <em>len</em>. </p>
<p>The function encodes MsgPack header (<em>only</em> header) for a string of length <em>len</em>. You should append actual string data to the buffer manually after encoding the header (exactly <em>len</em> bytes without trailing '\0').</p>
<p>This approach is very useful for cases when the total length of the string is known in advance, but the string data is not stored in a single continuous buffer (e.g. network packets).</p>
<p>It is your responsibility to ensure that <em>data</em> has enough space. Usage example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char buffer[1024];</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;char *b = buffer;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;b = mp_encode_strl(b, hdr.total_len);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;char *s = b;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;memcpy(b, pkt1.data, pkt1.len)</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;b += pkt1.len;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;// get next packet</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;memcpy(b, pkt2.data, pkt2.len)</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;b += pkt2.len;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;// get next packet</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;memcpy(b, pkt1.data, pkt3.len)</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;b += pkt3.len;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;// Check that all data was received</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;assert(hdr.total_len == (uint32_t) (b - s))</div>
</div><!-- fragment --><p> Hint: you can dynamically reallocate the buffer during the process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a buffer </td></tr>
    <tr><td class="paramname">len</td><td>- a string length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + mp_sizeof_strl(len) </dd></dl>
<dl class="section see"><dt>See also</dt><dd>mp_sizeof_strl() </dd></dl>

</div>
</div>
<a class="anchor" id="a49c473097cc682ec58c2ea69da40f2f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mp_encode_uint </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode an unsigned integer <em>num</em>. It is your responsibility to ensure that <em>data</em> has enough space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a buffer </td></tr>
    <tr><td class="paramname">num</td><td>- a number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + mp_sizeof_uint(<em>num</em>) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#aefb68eba767403432699c731cc953607">An usage example </a> </dd>
<dd>
mp_sizeof_uint() </dd></dl>

</div>
</div>
<a class="anchor" id="ada74df4f72bab98a89ac57aec6ae01b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mp_format </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a sequence of values according to format string. Example: mp_format(buf, sz, "[%d {%d%s%d%s}]", 42, 0, "false", 1, "true"); to get a msgpack array of two items: number 42 and map (0-&gt;"false, 2-&gt;"true") Does not write items that don't fit to data_size argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- a buffer </td></tr>
    <tr><td class="paramname">data_size</td><td>- a buffer size </td></tr>
    <tr><td class="paramname">format</td><td>- zero-end string, containing structure of resulting msgpack and types of next arguments. Format can contain '[' and ']' pairs, defining arrays, '{' and '}' pairs, defining maps, and format specifiers, described below: d, i - int u - unsigned int ld, li - long lu - unsigned long lld, lli - long long llu - unsigned long long hd, hi - short hu - unsigned short hhd, hhi - char (as number) hhu - unsigned char (as number) f - float lf - double b - bool s - zero-end string %.*s - string with specified length %% is ignored %&lt;smth else&gt;=""&gt; assert and undefined behaviour NIL - a nil value all other symbols are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of requred bytes. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>data_size means that is not enough space and whole msgpack was not encoded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf842a6e84f360fd9b9fc4dca35c8529"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mp_next </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip one element in a packed <em>data</em>. </p>
<p>The function is faster than mp_typeof + mp_decode_XXX() combination. For arrays and maps the function also skips all members. For strings and binstrings the function also skips the string data.</p>
<p>Usage example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;char buf[1024];</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;char *w = buf;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// First MsgPack object</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;w = mp_encode_uint(w, 10);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;// Second MsgPack object</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;w = mp_encode_array(w, 4);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   w = mp_encode_array(w, 2);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        // Begin of an inner array</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        w = mp_encode_str(w, &quot;second inner 1&quot;, 14);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        w = mp_encode_str(w, &quot;second inner 2&quot;, 14);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        // End of an inner array</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;   w = mp_encode_str(w, &quot;second&quot;, 6);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;   w = mp_encode_uint(w, 20);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;   w = mp_encode_bool(w, true);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;// Third MsgPack object</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;w = mp_encode_str(w, &quot;third&quot;, 5);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;// EOF</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;const char *r = buf;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;// First MsgPack object</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;assert(mp_typeof(**r) == MP_UINT);</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;mp_next(&amp;r); // skip the first object</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;// Second MsgPack object</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;assert(mp_typeof(**r) == MP_ARRAY);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;mp_decode_array(&amp;r);</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    assert(mp_typeof(**r) == MP_ARRAY); // inner array</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    mp_next(&amp;r); // --&gt;&gt; skip the entire inner array (with all members)</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    assert(mp_typeof(**r) == MP_STR); // second</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    mp_next(&amp;r);</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    assert(mp_typeof(**r) == MP_UINT); // 20</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    mp_next(&amp;r);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    assert(mp_typeof(**r) == MP_BOOL); // true</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    mp_next(&amp;r);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;// Third MsgPack object</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;assert(mp_typeof(**r) == MP_STR); // third</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;mp_next(&amp;r);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;assert(r == w); // EOF</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- the pointer to a buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + mp_sizeof_TYPE() where TYPE is mp_typeof(**data) </dd></dl>

</div>
</div>
<a class="anchor" id="a7a50574a11a134d27d093e9ea341622d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mp_vformat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mp_format variation, taking variable argument list Example: va_list args; va_start(args, fmt); mp_vformat(data, data_size, fmt, args); va_end(args); </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="index.html#ada74df4f72bab98a89ac57aec6ae01b9">mp_format()</a></dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 11 2016 16:47:59 for MsgPuck by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
